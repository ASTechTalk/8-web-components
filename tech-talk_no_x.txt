https://speakerdeck.com/1000ch/web-components-changes-web-development

Web Components
 HTML+CSS+JSの部品を新たな要素として再定義する
  ex) Google Mapの埋め込み、Twitterボタン

 UIである必要はなく、機能の抽象化も可能
  ex) Desktop Notification

 スコープが存在し、外部に干渉しない
  ex) CSSのid, class名

 将来、Webの標準になる予定
 
 Web Componentsを構成する4つの要素
  Custom Elements
  Templates
  HTML Imports
  Shadow DOM

  Custom Elements
    <<<
      var XElementPrototype = Object.create(HTMLElement.prototype);
      var XElement = document.registerElement('x-element', {
        prototype: XElementPrototype
      });
    >>>
    こんな感じでjs書いてやれば、
    <x-element>が使える(カスタム要素名にはハイフンを含める必要がある)

    設定できるコールバック
    createdCallback: 生成時に呼ばれる
    attachedCallback: ドキュメントに挿入された時に呼ばれる
    detachedCallback: ドキュメントから削除された時に呼ばれる
    attributeChangedCallback: 属性が変更された時に呼ばれる
    <<<
      var XElementPrototype = Object.create(HTMLElement.prototype);
      XElementPrototype.createdCallback = function(){
        console.log("created");
      };
      var XElement = document.registerElement('x-element', {
        prototype: XElementProtype
      });

      new XElement() // => "created"
    >>>

  Templates 
    描画されない不活性なテンプレート要素
    <<<
      <template id='tmpl'>
        <style>
          input, button {
            border:1px solid #000;
            border-radius: 3px;
          }
        </style>
        <input type='text'>
        <button>Button</button>
      </template>
    >>>

    DOMとして取得して扱うことができる
    パースされても描画されない
    クローンして追加されるまでは実行されない

  Shadow DOM
    Document -> HTMLElement -> (HTML+CSS+JS)
    Document -> HTMLElement -> ShadowRoot -> (HTML+CSS+JS)

    <<<
      var template = document.querySelector('#tmpl');
      var div = document.querySelector('div');

      var clone = document.importNode(template.content, true);
      var shadowRoot = div.createShadowRoot();

      shadowRoot.appendChild(clone);
    >>>

  HTML Import
    <<<
      <html>
        <head>
          <title>x-element</title>
          <link rel='import' href='x-element.html'>
        </head>
        <body>
          <x-element></x-element>
        </body>
      </html>


    // importされるとdocumentはimport元のdocumentになるため自身のドキュメントを取得する
    var importDoc = document.currentScript.ownerDocument;

    >>>

    JavaScriptやCSSを1リソースでロード可能
    依存関係が明確になる
    インポート先の<script>は描画をブロックしない
    async属性を付与可能
 
 Templateを使ったCustom ElementをShadow DOMで閉じてコンポーネント化し、importして使う

 でも、コンポーネント作るのめんどくね？
 　=> Polymer.js


 Polymer
   Web-Componentsのコンポーネントを簡単に作れる
   それ以外にも色々
   Web Componentsのhelper+αっぽい

 でも、IEとSafariが実装渋ってるらしい(polyfill使えば多少は動くけど)
 なので、まだはやい！

 vim
  * emmet.vim
  * unite.vim
  * vimshell
  * ...
 tmux
 grunt
  * grunt-contrib-watch(livereload)
 bower
